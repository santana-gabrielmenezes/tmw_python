Atalhos VS Code:

    Shift + Alt + i -> posiciona um cursor de ferente no final de cada linha selecionada

    Ctrl + d -> seleciona a próxima aparição do termo selecionado

    Ctrl + h -> abre uma caixa de diálogo para localizar e substituir uma palavra

    Home / End -> posiciona o(s) cursor(s) no início / fim da(s) linha(s)

comandos python:

    print(...) -> imprime, no terminal interpretador python, o texto inserido como parâmetro
        sep = ... -> parâmetro que define o separador entre os elementos da concatenação interna ao print()

    type(...) -> retorna o tipo de um objeto

    input(...) -> recebe infromação do usuário SEMPRE NO FORMATO DE STRING
        input(<texto>) -> exibe um texto antes de aguardara a infromação do usuário

    range(<valor start>,<valor stop>) -> cria uma estrutura de dados com valores entre o valor start e o valor stop
        o comando range() inclue o valor strar, mas não inclue na estrutura o valor stop
        se o valor start for omitido, por padrão será admitido como 0

    int(...) -> converte em tipo inteiro

    bool(...) -> retorna o booleano equivalente

    <objeto>.lower() -> retorna o texto em string com todas as letras minúsculas

    if <condições> : <comandos> -> executa o(s) comando(s) apenas se a condição for verdadeira

    else : <comandos> -> deve ser inserido após do if e funciona executando o comando quando a condição do(s) if não são verdadeiras

    elif <condições> : <comandos> -> funciona como um condional extra específico para quando a condição do if anterior não é verdadeira. É usado para deixar o código menos verboso substituindo o else seguido do if apenas pelo elif. Portanto ele é obrigatoriamente usado entre o if e o else

    while <condições> : <comandos> -> executa os comandos repetidamente enquanto a condição for True
        break -> sai do loop
        continue -> reinicia o laço ignorando
    
    for <variável> in <objeto> : <comandos> -> executa os comandos iterando, um a um, sobre todos cada um dos elementos de um objeto
        o i assume os valores dos elementos na oredem do primeiro ao ultimo até o fim do elemento durante as iterações

    <condição> and <condição> -> operador lógico and

    <expressão> == <expressão> -> operador lógico de igualdade expecificamente para os componentes de um objeto. retorna true se os componentes de dois objetos forem iguais, mas se forem objetos diferentes retorna false

    <expressão> != <expressão> -> operador lógico de desigualdade

    <expressão 1> in <expressão 2> -> retorna True se o(s) elemento(s) da expreção 1 está(s) contido(s) na expressão 2

    += e -= -> incrementa positivamente e negativamente (respectaivamente) o valor de uma variável

    # %% -> inicia uma célula de execução, as linhas a seguir serão executadas no Interactive py
        para abrir o "Interactive py" basta executar um .py iniciado por "# %%"
        para executar apenas a célula de execução use o atalho Shift + Enter

    /n -> insere uma quebra de texto (parágrafo) na string

    <dividendo> % <divisor> -> retorna o resto da divisão

    <dividendo> // <divisor> -> retorna a parte inteira do resultado da divisão

    <base> ** <expoente> -> retorna o resultado da exponenciação

    <nome da variável> = <valor da variável> -> inicializa e atribui valor a uma variável
        em células de, as variável apresentaram o último valor atribuido, não necessariamente o valor atribuido em linhas superiores

    <nome da lista> = [elementos] -> cria uma estrutura de lista com vários elementos
        diferente de um vetor (array), a lista pode ser constituida de elementos de tipos diferentes
        <variável>[número do elemento] -> acessa elementos de uma lista do primeiro ao ultimo sendo o primeiro elemento o de número 0.
            Para acessar elementos do ultimo ao primeiro usa-se valores negativos sendo o ultimo o de número -1

    len(<nome da lista>) -> retorna o número de elementos de uma lista

    sum(<nome da lista>) - retorna a soma dos valores dentro da lista

    <nome da lista>[<valor start>:<valor stop>:<valor step>] -> extra da lista os elementos, da posição valor start até o anterior à posição valor stop.
        o valor step indica quantos elementos serão "saltados" a cada retorno. este vlor é opicional e quando suprimido é admitido o valor padrão 1
        quando usados valores negativos, o retorno é feito do ultimo ao primeiro elemento da lista
        se o valor start for omitido, por padrão será admitido como 0

    <nome da lista>.append(...) -> insere um único valor no final da lista

    <nome da lista>.extend(...) -> insere, um a um, os valores de uma lista na lista a ser alterada

    <nome da lista> = <nome da lista> + <outra lista> -> concatena o valor da segunda lista na primeira. funciona como o .extend()

    <nome do dicionário>{'<noma da chave 1>' : <valor 1> , '<noma da chave 2>' : <valor 2> , '<noma da chave 3>' : <valor 3> , etc } -> cria uma estrutura chave/valor
        <nome do dicionário>['<nome da chave'] -> acessa o valor atribuido àquela chave

    <nome do dicionário>.keys() -> retorna uma lista com os nomes das chaves do dicionario

    <nome do dicionário>.values() -> retorna uma lista com os valores do dicionario
    
    <nome do dicionário>.items() -> retorna uma lista com os pares chave/valore do dicionario

    <nome da tupla> = (elementos) -> cria uma estrutura de lista IMUTÁVEL

    try : ... except : ... -> estrutura que indica ao python tentar execultar um(s) comando(s), caso resulte em erro, execulta outro(s) comando(s)

    def <nome da função>(<argumentos 1> , <argumentos 2> , etc) : <comandos> return <resultado da função> -> define uma função retornando o resultado da função
        uma função pode ter um, mais de um ou nenhum argumentos
        para criar argumentos não obrigatórios, basta inserir um valor padrão a este na definição da função acrecentando ao argumento =<valor padrão>
        o return funciona como o break da função finalizando-a
        a estrutura def <nome da função>(<argumentos>) é chamada de assinatura da função
    
    def <nome da função>(*<argumentos>) -> o * é usado para recebe um número indefinido de argumentos para a função
        podem existir mais de um argumento, desde que exista apenas um argumento com *

    <assinatura da função>'''<documentação da função>''' -> esta estrutura cria um texto que será exibido como documentação no helper da função onde esta for usada

    import <nome da biblioteca> -> importa uma biblioteca
        para que uma biblioteca seja usada deve ser obrigatoriamente importada antes
        uma biblioteca pode conter módulos, classes e funções
    
    import <nome da biblioteca> as <alias> -> importa uma biblioteca criando um apelido para ser usado no lugar do nome da biblioteca sempre que for invocar um elemento desta

    <nome da biblioteca>.<elemento da biblioteca>() -> invoca um elemento da biblioteca para ser usado no código

    from <nome da biblioteca> import <nome do elemento impotado> -> importa apenas um elemento específico da biblioteca
        quando importado desta forma, o elemento passa a ser parte do código e pode ser invocado sem o <nome da biblioteca>.

    <nome da variável> = open("<caminho do arquivo>", "tipo de abertura") -> abre arquivos
        caso o arquivo esteja no mesmo diretório não é necessario escrever o caminho completo, é possível suprimir a parte do caminho até o diretório atual
        o tipo de abertura "w" abre arquivos em modo de escrita, sobrescrevendo completamente o conteudo anterior do arquivo
        o tipo de abertura "a" abre arquivos em modo de escrita, adicionando o conteudo ao arquivo
        o tipo de abertura "r" abre arquivos em modo de leitura

    <variável arquivo>.write("texto") -> escreve dento do arquivo

    <nome da variável> = <variável arquivo>.read() -> lê todo o conteudo do arquivo e retorna uma string com este conteudo

    <nome da variável> = <variável arquivo>.readline("texto") -> lê todo o conteudo do arquivo e retorna uma lista com o conteudo de cada linha em uma posição da lista

    <variável arquivo>.close() -> fecha o arquivo

    with open("<caminho do arquivo>", "tipo de abertura") as <alias> : <comandos> -> mantem o arquivo aperto enquando os comandos estão sendo executados e fecha automaticamente ao finalizar os comandos
        é bastante útil para evitar o não fechamento do arquivo por esquecimento (por exemplo)
        também vai funcionar com qualquer outra estrutura que exiga o fechamento ao final como execuções de bancos de dados (por exemplo)

Nota:

    python <caminho do arquivo> <nome do arquivo .py> ->
        para acessar o interpretador python em qualquer terminal, basta escrever "python". O aparecimento de >>> indica que o interpretador foi aberto com sucesso
        é necessário ter instalado o python anteriormente

    para sair do interpretador python utilize o comando "exit()" + Enter

    para comentar, basta usar o # no início da linha

    entre o if e o else não podem haver comandos (exceto pelo elif). o if/else funciona como um bloco de comando onde a identação (especificamente identação de 4 espaços) identifica o bloco.

    para o condicional a estrutura é if (obrigatório apenas um e no início), elif (opcional quantos desejar entre o if e o else) e else (opcional apenas um e no final)

    o true e o false podem ser executados como 1 e 0 inclusive em operações matemáticas

    o operador and pode ser interpretado como multiplicação enquanto o or pode ser interpretado como soma

    tabela verdade and :    true    and     true        1 * 1       1 (true)
                            true    and     false   =   1 * 0   =   0 (false)
                            false   and     true        0 * 1       0 (false)
                            false   and     false       0 * 0       0 (false)

    tabela verdade or :     true    or     true        1 + 1       2 (true)
                            true    or     false   =   1 + 0   =   1 (true)
                            false   or     true        0 + 1       1 (true)
                            false   or     false       0 + 0       0 (false)

    métodos são ações que o python pode executar em cima de objetos

    os objetos podem ser classificados como mutaveis ou imutaveis
        mutáveis: métodos aplicados a estes mudam o objeto e retornam este alterado
        imutáveis: métodos aplicados a estes não mudam o objeto, mas retornam um novo objeto com as alterações aplicadas mantendo o objeto original intacto

    strings podem ser interpretadas como listas. inclusive as ações e metodos usados para listas podem ser usados em strings como se cada letra fosse um elemento

    na declaração de uma função, os valores obrigatórios devem ser declarados antes dos opcionais

    não é boa prática com bibliotecas impota-las por completo. Algumas bibliotecas são muito grandes e podem deixar seu código pesado

    é boa prática com bibliotecas sempre usar o <nome da biblioteca>. antes de um elemento para invoca-lo pois identifica a origem daquele elemento não nativo